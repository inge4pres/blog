<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>
    infrastructure - inge4pres
  </title><meta name="generator" content="Hugo 0.98.0" /><link
    rel="stylesheet"
    href="https://inge.4pr.es/css/styles.css"
    integrity=""
  />
  
  <script>
    
    if (window.matchMedia("(prefers-color-scheme: dark)").matches) {
      document.documentElement.classList.add("dark");
    } else {
      document.documentElement.classList.remove("dark");
    }
  </script>
  
</head>

  <body
    class="flex flex-col min-h-screen dark:bg-gray-900 dark:text-gray-100 transition-colors duration-500"
  ><header class="w-full px-4 pt-4 max-w-5xl mx-auto">
  <nav class="flex items-center justify-between flex-wrap">
    <div class="flex gap-2 items-center">
      
      <a href="mailto:fgualazzi@gmail.com" aria-label="EMail">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="20"
          height="20"
          viewBox="0 0 24 24"
          stroke-width="1.5"
          stroke="currentColor"
          fill="none"
          stroke-linecap="round"
          stroke-linejoin="round"
        >
          <path stroke="none" d="M0 0h24v24H0z" fill="none" />
          <circle cx="12" cy="12" r="4" />
          <path d="M16 12v1.5a2.5 2.5 0 0 0 5 0v-1.5a9 9 0 1 0 -5.5 8.28" />
        </svg>
      </a>
      
      <a href="https://inge.4pr.es/" class="flex items-center font-bold">
        inge4pres
      </a>
    </div>

    <ul id="nav-menu" class="flex w-auto mt-0 space-x-2">
      
      <li>
        <a href="https://inge.4pr.es/about/" class="hover:text-blue-800 dark:hover:text-blue-300">You are what you is (F. Zappa)</a>
      </li>
      
      
      <li>
        <a href="https://inge.4pr.es/categories/blog/" class="hover:text-blue-800 dark:hover:text-blue-300">blog</a>
      </li>
      
    </ul>
  </nav>
</header>
<main class="flex-1 mx-4 md:mx-12 lg:mx-24 mt-8 sm:mt-16"> 
<article class="sm:mx-12 mb-16 prose lg:prose-lg">
  <h1><a href="https://inge.4pr.es/post/grpc-traffic-mirroring-with-ingress-nginx-on-k8s/">gRPC Traffic Mirroring With Ingress-Nginx on K8s</a></h1>
  <p>In a <a href="https://inge.4pr.es/post/grpc-traffic-mirroring-using-nginx/">previous post</a> we saw an NGINX configuration to allow gRPC traffic mirroring.</p>
<p>Is the same technique applicable on Kubernetes?
Yes! Using the <a href="https://github.com/kubernetes/ingress-nginx">ingress-nginx</a> ingress controller!</p>
<h3 id="traffic-mirroring">Traffic mirroring</h3>
<p>Use the following configurations snippets in the <a href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/">ingress-nginx configMap</a>
and in the Ingress manifest to mirror <strong>all traffic</strong> to a separate gRPC server.</p>
<h4 id="configmap">ConfigMap</h4>
<p>Replace <code>grpc-backend.company.net</code> and <code>grpc-mirror.company.net</code> with the original and mirror endpoint, respectively.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span>    <span style="color:#ff79c6">http-snippet</span>: |<span style="color:#f1fa8c">
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">      server {
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">        listen 127.0.0.1:9443 ssl http2;
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">        server_name grpc-backend.company.net;
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">        grpc_ssl_protocols TLSv1.3;
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">        ssl_certificate_by_lua_block {
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">          certificate.call()
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">        }
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">        location / {
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">          grpc_pass grpcs://grpc-mirror.company.net:443;
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">        }
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">      }</span>      
</span></span></code></pre></div><h4 id="ingress">Ingress</h4>
<p>Add the following annotations in the Ingress manifest defining the endpoint of your gRPC service.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span>    <span style="color:#ff79c6">nginx.ingress.kubernetes.io/backend-protocol</span>: GRPC
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">nginx.ingress.kubernetes.io/configuration-snippet</span>: |<span style="color:#f1fa8c">
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">      </span>      mirror /mirror;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">nginx.ingress.kubernetes.io/server-snippet</span>: |<span style="color:#f1fa8c">
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">      location = /mirror {
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">        internal;
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">        proxy_set_header X-Mirrored-From $http_host;
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">        proxy_pass https://127.0.0.1:9443$request_uri;
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">      }</span>      
</span></span></code></pre></div><h4 id="nginx-configuration-details">NGINX configuration details</h4>
<p>Compared to the <a href="grpc-traffic-mirroring-using-nginx.md#the-solution">non-K8s version</a> we have some differences:</p>
<p>In the main <code>nginx.conf</code> file, applied through the configMap, we have a weird section.</p>
<pre><code>ssl_certificate_by_lua_block {
  certificate.call()
}
</code></pre>
<p>This is a something I discovered while looking in the ingress-nginx source: it&rsquo;s a helper used to load the right TLS certificate
which is impossible to do otherwise, because TLS certificates are stored in Kubernetes secrets, instead of normal files.
This replaces the TLS certificate loading directives.</p>
<p>The rest is unchanged.</p>
<p>The Ingress resource manifest contains the annotation to configure a gRPC backend <code>nginx.ingress.kubernetes.io/backend-protocol: GRPC</code>
and has 2 important settings.</p>
<p>The first snippet</p>
<pre><code>nginx.ingress.kubernetes.io/configuration-snippet: |
  mirror /mirror;
</code></pre>
<p>adds the mirroring directive to the virtual server location, to copy the gRPC traffic to the <code>/mirror</code> internal location.</p>
<p>The second snippet</p>
<pre><code>nginx.ingress.kubernetes.io/server-snippet: |
  location = /mirror {
    internal;
    proxy_set_header X-Mirrored-From $http_host;
    proxy_pass https://127.0.0.1:9443$request_uri;
 }
</code></pre>
<p>creates the internal location that will proxy the traffic to the additional server created in the configMap above.</p>
<p>That&rsquo;s it for copying <em>all</em> traffic from an ingress to a separate server!
But what if we&rsquo;d like to only mirror <em>a portion</em> of the traffic?</p>
<p>At the end of a previous post I left as a homework for the readers to discover how to copy only a percentage of traffic.
Read on to see how to achieve it.</p>
<h3 id="bonus-mirror-a-part-of-traffic">Bonus: mirror a part of traffic</h3>
<p>NGINX has a <a href="https://nginx.org/en/docs/http/ngx_http_split_clients_module.html"><code>split_clients</code> module</a> that is capable
of setting a variable based on the <em>distribution of an input</em>. The variable can be used in virtual servers to apply
conditional configurations.</p>
<p>The syntax to configure the module is</p>
<pre><code>split_clients &lt;input string&gt; &lt;variable&gt; {
  5% something;
  10% nothing;
  * &quot;&quot;;
}
</code></pre>
<p>with the value of <code>&lt;variable&gt;</code> being set based on the hash of <code>&lt;input string&gt;</code>: this can be anything that NGINX assigns
when processing a request.</p>
<p>The important detail to understand of the above configurations, is how to choose the input string: the percentage defines
the portion of hash values that will yield in <code>&lt;variable&gt;</code> the value to its right.</p>
<p>Let&rsquo;s have a look at the configs.</p>
<p>NGINX configMap:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span>    <span style="color:#ff79c6">http-snippet</span>: |<span style="color:#f1fa8c">
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">      split_clients &#34;${remote_addr}mirror${request_uri}&#34; $mirror_backend {
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">        10% 1;
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">        * &#34;&#34;;
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">      }
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">      server {
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">        listen 127.0.0.1:9443 ssl http2;
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">        server_name original.domain.com;
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">        grpc_ssl_protocols TLSv1.3;
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">        ssl_certificate_by_lua_block {
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">          certificate.call()
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">        }
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">        location / {
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">          grpc_pass grpcs://destination.domain.com:443;
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">        }
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">      }</span>      
</span></span></code></pre></div><p>Ingress manifest:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span>    <span style="color:#ff79c6">nginx.ingress.kubernetes.io/backend-protocol</span>: GRPC
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">nginx.ingress.kubernetes.io/configuration-snippet</span>: |<span style="color:#f1fa8c">
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">      </span>      mirror /mirror;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">nginx.ingress.kubernetes.io/server-snippet</span>: |<span style="color:#f1fa8c">
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">      location = /mirror {
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">        internal;
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">        if ($mirror_backend = &#34;&#34;) { 
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">          return 200; 
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">        }
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">        proxy_set_header X-Mirrored-From $http_host;
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">        proxy_pass https://127.0.0.1:9443$request_uri;
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">      }</span>      
</span></span></code></pre></div><p>The additions to the previous config: with <code>split_clients</code> in the main nginx.conf file we set a variable <code>$mirror_backend</code>
with a non-empty string when the hash of <code>&quot;${remote_addr}mirror${request_uri}&quot;</code> falls in the <em>first</em> 10% of all possible
hash values.
The <code>if</code> added in the Ingress manifest will only proxy traffic when the <code>$mirror_backend</code> variable is not empty.</p>
<p>The hash value can be from 0 to 4294967295 (NGINX uses <a href="https://en.wikipedia.org/wiki/MurmurHash#MurmurHash2">MurMurHash2</a>,
returning a 32-bit integer); the percentages written in the configuration create segments of the whole hash space in a
contiguous manner, starting from 0.</p>
<p>In the example above where we defined <code>5%</code>, <code>10%</code> and <code>*</code>, you will have 3 ranges of possible values for <code>&lt;variable&gt;</code>:</p>
<ul>
<li><code>5%</code> -&gt; hash values from 0 to 214748364</li>
<li><code>10%</code> -&gt; hash values from 214748365 to 429496728</li>
<li><code>*</code> -&gt; all remaining hash values from 429496729 to 4294967295</li>
</ul>
<p>Therefore, the probability of getting each value is not <em>exactly</em> the same of the percentage configured,
because the distribution of hashes tightly depends on the input.</p>
<p>For example, if you have most of your traffic from a few <code>$remote_address</code>es, you don&rsquo;t want to set it as input alone.
The more you have a sparse distribution of values in the input variable, the better the filter will work.</p>
<p>This is why in the example configuration, I added <code>$request_uri</code> to the input, concatenating with a constant string
<code>mirror</code>: this highly increases the entropy of the hashes, making the percentage more reliable.</p>
<p>An important property of hashing the input is that it&rsquo;s deterministic, so if you want to mirror <em>exactly</em> for a subset
of requests, you can do it: define the percentages to include only the portion of hashes that you want to be copied.</p>
<p>For example, if you want to mirror only traffic for a certain URI, as in:</p>
<pre><code>$request_uri        = `/bank.Service/askForTransactions`
murmurhash2         = 1227040391
range percentage    = 28.57%
</code></pre>
<p>then the <code>split_clients</code> config would be</p>
<pre><code>split_clients $request_uri $mirror_backend {
  28.5699% &quot;&quot;;
  28.57% 1;
  * &quot;&quot;;
}
</code></pre>
<h3 id="drawbacks-and-limitations">Drawbacks and limitations</h3>
<p>Copying traffic using this technique is simple and effective, but it has a cost: we have a number of TCP connections
that are dedicated to serving the cloned traffic, even if going through the loopback interface.</p>
<p>You will notice from the ingress-nginx controller metrics that enabling the virtual server via the configMap does not
create more connections immediately, but as soon as you configure an Ingress to mirror using the new server, there will
be an increase in the average open connections.</p>
<p>This is expected, because of the non-native way we are doing mirroring for gRPC traffic.</p>
<p>The same applies to memory and CPU usage: handling more connections, and decrypting and re-encrypting every gRPC call
will come with a resource overhead.</p>
<p>One more thing to note: this technique <em>might</em> be working with gRPC streams, but I was only able to test it with unary
RPCs.</p>
<h3 id="credit">Credit</h3>
<p>Thanks again to Joni (<a href="https://twitter.com/mejofi">@mejofi</a>) for helping me find the original gRPC traffic mirroring configuration.</p>
<p>The partial mirroring addition is taken from this nice blog post by Alex Dzyoba
<a href="https://alex.dzyoba.com/blog/nginx-mirror/">https://alex.dzyoba.com/blog/nginx-mirror/</a></p>

</article>

<article class="sm:mx-12 mb-16 prose lg:prose-lg">
  <h1><a href="https://inge.4pr.es/post/grpc-traffic-mirroring-using-nginx/">gRPC Traffic Mirroring Using NGINX</a></h1>
  <p>Recently at work with the <a href="https://optimyze.cloud">Optimyze</a> team we faced the necessity of copying traffic from our current customer-facing environment to a new environment.
We have assumptions and ideas about architectural changes that cannot be validated only with synthetic tests and require cloning traffic to a separate, internal testing environment.</p>
<p>There is no better test than the one performed with real-world data: when you hear speaking about <em>testing in production</em>, a deployment of a new feature to &ldquo;see what happens&rdquo; is not what I have in mind.
I think of techniques that allow testing <em>with</em> production such as traffic mirroring (or <em>shadowing</em>), canary releases, A/B testing and feature flags.</p>
<p>These techniques will allow gathering data directly from your customers, in the form of raw input data (web/API requests) or feedback recorded from customers&rsquo; interaction with a new product version.</p>
<p>In the case of traffic mirroring we don&rsquo;t introduce any changes to a production system, we simply copy the traffic (entirely or a portion of it) into a different system, for internal analysis.
When applying this technique, security considerations apply: you do not want to leak customers data into a non-production system,
so ensure you apply the same security policies to the shadow infrastructure receiving a copy of production traffic.</p>
<h3 id="tldr">TL;DR</h3>
<p><strong>If you&rsquo;re in a rush and don&rsquo;t care about the details, the solution is <a href="#the-solution">here</a>.</strong></p>
<h3 id="the-problem">The problem</h3>
<p>We ♥ NGINX!
We knew it has the ability to serve as <a href="https://www.nginx.com/blog/nginx-1-13-10-grpc/">reverse proxy for gRPC services</a>,
and it has <a href="https://nginx.org/en/docs/http/ngx_http_mirror_module.html">built-in support for mirroring</a>.</p>
<p>What we didn&rsquo;t know is that mirroring gRPC traffic has a caveat: URI rewrite is not possible within the <code>grpc_pass</code> directive.
This means that traffic copied over to a new location (as described in the mirroring module docs) will have an URI set with the mirror location, making the service unable to map it with any RPC when received.</p>
<h3 id="debugging-nginx-capabilities">Debugging NGINX capabilities</h3>
<p>NGINX documentation is not very rich of examples or references to complex configurations, it is often left to the user
to build the desired outcome using the various building blocks offered by the modules.</p>
<p>In the case of traffic mirroring, the documentation states:</p>
<pre tabindex="0"><code>Sets the URI to which an original request will be mirrored. 
Several mirrors can be specified on the same configuration level.
</code></pre><p>In first instance we thought we could simply copy directly the traffic together with <code>grpc_pass</code> in a naive configuration like the following (<strong>not working as intended!</strong>):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nginx" data-lang="nginx"><span style="display:flex;"><span><span style="color:#ff79c6">server</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">listen</span> <span style="color:#bd93f9">443</span> <span style="color:#f1fa8c">ssl</span> <span style="color:#f1fa8c">http2</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">server_name</span> <span style="color:#f1fa8c">grpc-backend.company.net</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">ssl_certificate</span> <span style="color:#f1fa8c">/etc/letsencrypt/live/company.net/fullchain.pem</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">ssl_certificate_key</span> <span style="color:#f1fa8c">/etc/letsencrypt/live/company.net/privkey.pem</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">root</span> <span style="color:#f1fa8c">/var/www/default</span>;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">location</span> <span style="color:#f1fa8c">/</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">mirror</span> <span style="color:#f1fa8c">/grpc-mirror</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">grpc_pass</span> <span style="color:#f1fa8c">grpc://production-upstream:12345</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">location</span> = <span style="color:#f1fa8c">/grpc-mirror</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">internal</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">grpc_pass</span> <span style="color:#f1fa8c">grpcs://mirror-upstream:443</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Note 2 things here:</p>
<ul>
<li>we are using NGINX to do TLS termination and we have a production service listening at <code>production-upstream:12345</code> for unencrypted traffic</li>
<li>we are re-encrypting traffic when copying over to the mirror because we want to emulate the full end-to-end traffic that a client would generate, and that includes TLS termination</li>
</ul>
<p>This may not apply to you but I prefer to sponsor a secure-by-default configuration, you can get free and automated TLS certificates with <a href="https://letsencrypt.org/">LetsEncrypt</a>.</p>
<p>We noticed the shadow environment was not processing data, so it was time to enable some debugging and see what was happening.</p>
<p>We add some logging to help us troubleshoot what is going on.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nginx" data-lang="nginx"><span style="display:flex;"><span>	<span style="color:#ff79c6">location</span> <span style="color:#f1fa8c">/</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">mirror</span> <span style="color:#f1fa8c">/grpc-mirror</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">grpc_pass</span> <span style="color:#f1fa8c">grpc://production-upstream:12345</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">location</span> = <span style="color:#f1fa8c">/grpc-mirror</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">internal</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">grpc_pass</span> <span style="color:#f1fa8c">grpcs://mirror-upstream:443</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">error_log</span> <span style="color:#f1fa8c">debug</span>;
</span></span></code></pre></div><p>We can now find these messages in the logs:</p>
<pre tabindex="0"><code>2021/05/27 20:15:51 [debug] 15765#15765: *1 http upstream request: &#34;/grpc-mirror?&#34;
2021/05/27 20:15:51 [debug] 15765#15765: *1 grpc header: &#34;grpc-message: malformed method name: &#34;/grpc-mirror&#34;&#34;
</code></pre><p>As documented, the <code>mirror-upstream</code> server receives a request with URI <code>/grpc-mirror</code>, making it useless on the receiving end and creating a path mismatch.</p>
<p>At this point we thought native gRPC mirroring was not possible with NGINX and we tried to copy the traffic via the kernel network stack.</p>
<p>So we introduced a new server on a different port, willing to direct there the traffic <em>outside</em> of NGINX.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nginx" data-lang="nginx"><span style="display:flex;"><span><span style="color:#ff79c6">server</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">listen</span> <span style="color:#bd93f9">9443</span> <span style="color:#f1fa8c">ssl</span> <span style="color:#f1fa8c">http2</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">ssl_certificate</span> <span style="color:#f1fa8c">/etc/letsencrypt/live/company.net/fullchain.pem</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">ssl_certificate_key</span> <span style="color:#f1fa8c">/etc/letsencrypt/live/company.net/privkey.pem</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">root</span> <span style="color:#f1fa8c">/var/www/default</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">server_name</span> <span style="color:#f1fa8c">grpc-backend.company.net</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">location</span> <span style="color:#f1fa8c">/</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">grpc_pass</span> <span style="color:#f1fa8c">grpcs://mirror-upstream:443</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">server</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">listen</span> <span style="color:#bd93f9">443</span> <span style="color:#f1fa8c">ssl</span> <span style="color:#f1fa8c">http2</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">ssl_certificate</span> <span style="color:#f1fa8c">/etc/letsencrypt/live/company.net/fullchain.pem</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">ssl_certificate_key</span> <span style="color:#f1fa8c">/etc/letsencrypt/live/company.net/privkey.pem</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">root</span> <span style="color:#f1fa8c">/var/www/default</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">server_name</span> <span style="color:#f1fa8c">grpc-backend.company.net</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">location</span> <span style="color:#f1fa8c">/</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">grpc_pass</span> <span style="color:#f1fa8c">grpc://production-upstream:12345</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>When we thought about cloning raw TCP traffic we also had to include TLS termination for the cloned traffic.</p>
<p>With this we are thinking we&rsquo;ll keep the same desired testing properties because the traffic will be cloned without NGINX knowing it,
so we tried with iptables rules using the <code>TEE</code> target only to realize minutes later that cloning TCP packets simply does not work because the protocol
is stateful and there is no way for the kernel to handle duplicated responses from a second client that has never been tracked.</p>
<p>Using a separate server is key to the correct solution presented below (thanks <a href="https://twitter.com/mejofi">@mejofi</a> for the brilliant idea).</p>
<h3 id="the-solution">The solution</h3>
<p>The trick is to combine the gRPC module with the proxy module to achieve the URI rewrite that is needed.</p>
<p>Here is a working gRPC traffic mirroring configuration:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nginx" data-lang="nginx"><span style="display:flex;"><span><span style="color:#ff79c6">server</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">listen</span> 127.0.0.1:<span style="color:#bd93f9">9443</span> <span style="color:#f1fa8c">ssl</span> <span style="color:#f1fa8c">http2</span>;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">ssl_certificate</span> <span style="color:#f1fa8c">/etc/letsencrypt/live/company.net/fullchain.pem</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">ssl_certificate_key</span> <span style="color:#f1fa8c">/etc/letsencrypt/live/company.net/privkey.pem</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">root</span> <span style="color:#f1fa8c">/var/www/default</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">server_name</span> <span style="color:#f1fa8c">grpc-backend.company.net</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">location</span> <span style="color:#f1fa8c">/</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">grpc_pass</span> <span style="color:#f1fa8c">grpcs://mirror-upstream:443</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">server</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">listen</span> <span style="color:#bd93f9">443</span> <span style="color:#f1fa8c">ssl</span> <span style="color:#f1fa8c">http2</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">ssl_certificate</span> <span style="color:#f1fa8c">/etc/letsencrypt/live/company.net/fullchain.pem</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">ssl_certificate_key</span> <span style="color:#f1fa8c">/etc/letsencrypt/live/company.net/privkey.pem</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">root</span> <span style="color:#f1fa8c">/var/www/default</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">server_name</span> <span style="color:#f1fa8c">grpc-backend.company.net</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">location</span> <span style="color:#f1fa8c">/</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">mirror</span> <span style="color:#f1fa8c">/grpc-mirror</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">grpc_pass</span> <span style="color:#f1fa8c">grpc://production-upstream:12345</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">location</span> = <span style="color:#f1fa8c">/grpc-mirror</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">internal</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">proxy_pass</span> <span style="color:#f1fa8c">https://127.0.0.1:9443</span><span style="color:#8be9fd;font-style:italic">$request_uri</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>In the snippets, the definition of upstream servers has been omitted.</strong> The configuration is not valid without them!</p>
<p>What we have here:</p>
<ul>
<li>the second server now listens on the loopback interface to avoid traffic leaving the NIC</li>
<li>the un-encrypted traffic is mirrored to an <code>internal</code> location</li>
<li>a <code>proxy_pass</code> directive that will set the original URI in the next upstream, proxying the traffic the loopback server</li>
<li>the <code>grpc_pass</code> in the loopback server will re-encrypt and pass the request to the shadow environment, but with the right gRPC path URI</li>
</ul>
<p><strong>Pay attention</strong>: the previous configuration will copy <em>all traffic</em> from a production gRPC service into a shadow environment.</p>
<p>It is left as an exercise to the reader to find the proper way of shadowing only a portion of the traffic (hint: check the
<a href="https://nginx.org/en/docs/http/ngx_http_split_clients_module.html">split_clients_module</a>).</p>
<p>A further improvement could be to use a UNIX socket for the server that will proxy requests to <code>mirror-upstream</code>,
on some OSes it might be faster than TCP proxying. I didn&rsquo;t test it yet but it looks like a possible combination offered
by <code>listen</code> and <code>proxy_pass</code> (the URI rewrite <em>should</em> be possible).</p>
<h3 id="conclusions">Conclusions</h3>
<p>Traffic mirroring is a key enabler for so many scenarios that it should be a first class citizen in any major webserver, for every protocol.</p>
<p>NGINX configuration can be treated as an art, given the infinite possibilities the server offers with its modularity.</p>
<p>I hope this post will save you some hours of debugging and will increase your testing capabilities,
I decided to write it because I could not find a complete answer online do the question: &ldquo;can NGXIN mirror gRPC traffic?&rdquo;.
And the answer is &ldquo;yes&rdquo;!</p>

</article>

<article class="sm:mx-12 mb-16 prose lg:prose-lg">
  <h1><a href="https://inge.4pr.es/post/2013-10-07-zabbix-a-powerful-yet-simple-monitoring-software/">Zabbix: a powerful yet simple monitoring software</a></h1>
  <p>It may come in mind to any IT system engineer to know what is the status of the network, server by server, instance by instance; it happened to me when I was given the responsibility to manage my company’s infrastructure and I was wondering which tool could have helped to do the job.</p>
<p>I chose Zabbix to monitor my infrastructure because:</p>
<ol>
<li>despite it’s a bit difficult to install (you need a PHP enabled web server, a database and a C compiler), you will benefit a very user-friendly web interface with lots of functionalities</li>
<li>native agents for major OS release are already complied: FreeBSD, Linux, Windows, etc… Compiling to other OS just requires a “configure &amp;&amp; make &amp;&amp; make install”</li>
<li>it offers many monitoring methods via a unique interface: you can group SNMP, JMX, HTTP monitoring in one shot</li>
<li>it has multi-step HTTP/HTTPS monitoring, simulating different browsers and clients</li>
<li>you can build nice infographics bundling all kind of monitored datas</li>
<li>you can manage users and roles to give access to the web interface at your company’s employees</li>
<li>you can build custom monitoring scripts to your needs</li>
</ol>
<p>Well let’s see some action now: I would like to post a short tutorial on how to build a custom script to monitor resources used by a Glassfish application server. You can use this methodology for other application servers or services.</p>
<p><strong>Requirements:</strong> you have installed Zabbix server, deployed an agent to a host, set up the necessary networking stuff</p>
<p>On the host to be monitored, you will have a directory where the agent configuration file is located (usually /usr/local/etc or C:\Zabbix)</p>
<p><strong>Step 1: enable custom parameters <strong>parsing</strong></strong></p>
<p>Edit the file zabbix_agent.conf or zabbix_agentd.conf (depending if you’re usgin the daemon or not) and uncommment/add the following line:</p>
<p><em>Include=/usr/local/etc/zabbix_agentd.conf.d/  <em>or</em> <em>Include=/usr/local/etc/zabbix_agent.conf.d/</em></em></p>
<p><strong>Step 2: write the script</strong></p>
<p>Create a file, name it as you please and insert the script you want to be executed by the agent: I needed a script that would inetract with Glassfish, so I used th following:</p>
<blockquote>
<p># Flexible parameter to grab global variables. On the frontend side, use keys like glassfish.status[server.jvm.heapsize-current].</p>
</blockquote>
<blockquote>
<p># Key syntax is glassfish.status[monitoring-key].</p>
</blockquote>
<blockquote>
<p>UserParameter=glassfish.status[*],/opt/glassfish/bin/asadmin get –user admin –passwordfile /opt/glassfish/bin/.pwd -m $1 | cut -d “=” -f 2 | tr -d ‘ ‘ | bc</p>
</blockquote>
<p>The script syntax is always UsrParameter=name.of.script[*] followed by the code to be executed. This one uses the Glassfish utility “<em>asadmin</em>” and a couple of shell commands to trim the string output and translate it into an integer value. You can see the arguments array can be retrieved using $ and index of argument. In this example you will call the script with one argument only (the monitoring data you want from Glassfish).</p>
<p><strong>Step 3: start harvesting datas!</strong></p>
<p>Once finished editing the script, go back to the Zabbix monitoring console and add an Item to the host you are monitoring. You will add the key as shown in the picture below:</p>
<p> </p>
<p><a href="https://inge.4pr.es/blog/wp-content/uploads/2013/10/zabbix_custom_script1.png"><!-- raw HTML omitted --></a></p>
<p> </p>
<p> </p>
<p>Then go back to the dashboard and verify that the script just created is returning datas as expected. In the section <em>Monitoring-&gt;Latest Data</em> check if the item is giving the expected values. In this exemple I chose to monitor the current heap size used by the server. One cool thing is: once the script is done you can call it with all the parameters Glassfish has, and then combine datas in an infograph like the following:</p>
<p> </p>
<p><a href="https://inge.4pr.es/blog/wp-content/uploads/2013/10/zabbix_graphs1.png"><!-- raw HTML omitted --></a></p>
<p> </p>
<p>Here I put together two Glassfish parameters (JVM upper bound and current heap used) and a system parameter (free memory).</p>
<p>To get a list of all parameters you can monitor via Glassfish <em>asadmin</em> command see Glassfish documentation <!-- raw HTML omitted -->here<!-- raw HTML omitted -->.</p>
<p>Cheers,</p>
<p>inge4pres</p>
<p> </p>

</article>
 
    </main><footer class="w-full text-center p-4 text-xs text-gray-400">
  <p>
    Built with
    <a
      href="https://gohugo.io"
      target="_blank"
      rel="noopener noreferrer"
      class="underline hover:text-blue-800 dark:hover:text-blue-300"
      >Hugo</a
    >
    and
    <a
      href="https://github.com/apvarun/showfolio-hugo-theme"
      target="_blank"
      rel="noopener noreferrer"
      class="underline hover:text-blue-800 dark:hover:text-blue-300"
      >Showfolio</a
    >
  </p>
</footer>

</body>
</html>
